<!DOCTYPE html>
<!--suppress ALL -->
<html lang="en">
<head>
    <title>three.js webgl - cloth simulation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #000;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            padding: 10px;
            width: 100%;
            text-align: center;
        }

        a {
            text-decoration: underline;
            cursor: pointer;
        }

    </style>
</head>

<body>
<div id="info">Simple Cloth Simulation<br/>
    Verlet integration with relaxed constraints<br/>
    <a onclick="wind = !wind;">Wind</a> |
    <a onclick="sphere.visible = !sphere.visible;">Ball</a> |
    <a onclick="togglePins();">Pins</a>
</div>

<!--<script src="node_modules/three/build/three.js"></script>-->

<script src="node_modules/react/umd/react.development.js"></script>
<script src="node_modules/react-dom/umd/react-dom.development.js"></script>

<script>
  var THREE;
</script>

<script src="./dist/bundle.js"></script>

<script src="node_modules/three/examples/js/Detector.js"></script>
<script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
<script src="node_modules/three/examples/js/libs/stats.min.js"></script>
<script src="node_modules/three/examples/js/Cloth.js"></script>
<script src="node_modules/babel-standalone/babel.min.js"></script>


<!--
<script src="node_modules/react/umd/react.development.js"></script>
<script src="node_modules/react-dom/umd/react-dom.development.js"></script>

<script src="js/Cloth.js"></script>

<script>
  function onReady(initializeExample) {
    initializeExample("cloth");
  }
</script>
<script src="./dist/bundle.js"></script>

-->

<script type="text/babel">

  /* testing cloth simulation */

  var pinsFormation = [];
  var pins = [6];

  pinsFormation.push(pins);

  pins = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  pinsFormation.push(pins);

  pins = [0];
  pinsFormation.push(pins);

  pins = []; // cut the rope ;)
  pinsFormation.push(pins);

  pins = [0, cloth.w]; // classic 2 pins
  pinsFormation.push(pins);

  pins = pinsFormation[1];


  function togglePins() {

    pins = pinsFormation[~~(Math.random() * pinsFormation.length)];

  }

  if (!Detector.webgl) Detector.addGetWebGLMessage();

  var container, stats;
  var camera, scene, renderer;

  var clothGeometry;
  var sphere;
  var object;

  var ClothExample;

  init();
  animate();

  function init() {
    //
    container = document.createElement('div');
    document.body.appendChild(container);

    console.log("!?");

    var rendererRef = function (_renderer) {
      renderer = _renderer;
    };

    var sceneRef = function (_scene) {
      scene = _scene;
    };

    var cameraRef = function (_camera) {
      camera = _camera;
    };

    const resourceRenderer = new ResourceRenderer();

    const resourceContainer = {};

    let clothTexture;

    const resources = resourceRenderer.render(<resources>
      <parametricGeometry
        func={clothFunction}
        slices={cloth.w}
        stacks={cloth.h}
        resource-id="clothGeometry"
      />
      <meshLambertMaterial
        side={THREE.DoubleSide}
        resource-id="clothMaterial"
        alphaTest={0.5}
      >
        <texture
          url="textures/patterns/circuit_pattern.png"
          resource-id="clothTexture"
          anisotropy={16}
        />
      </meshLambertMaterial>
    </resources>, resourceContainer);

    const clothMaterial = resources.get("clothMaterial");

    // console.log("material", clothMaterial);

    clothGeometry = resources.get("clothGeometry");

    clothTexture = clothMaterial.map;

    console.log(resources);

    const sphereRef = (_sphere: Mesh) => {
      sphere = _sphere;
    };

    var ballGeo = new THREE.SphereBufferGeometry(ballSize, 32, 16);

    ClothExample = class ClothExample extends React.Component {
      render() {
        const d = 300;

        return <React3>
          <webGLRenderer
            width={window.innerWidth}
            height={window.innerHeight}
            devicePixelRatio={window.devicePixelRatio}

            ref={rendererRef}
          >
            <scene
              ref={sceneRef}
              background={new THREE.Color(0xCCE0FF)}
              fog={new THREE.Fog(0xCCE0FF, 500, 10000)}
            >
              <perspectiveCamera
                ref={cameraRef}
                fov={30}
                aspect={window.innerWidth / window.innerHeight}
                near={1}
                far={10000}
                position={new THREE.Vector3(1000, 50, 1500)}
              />
              <ambientLight
                color={0x666666}
              />
              <directionalLight
                color={0xdfebff}
                intensity={1}
                position={new THREE.Vector3(50, 200, 100)
                  .multiplyScalar(1.3)}
                castShadow
                shadow={<directionalLightShadow
                  mapSize={new THREE.Vector2(1024, 1024)}
                  camera={<orthographicCamera
                    left={-d}
                    right={d}
                    top={d}
                    bottom={-d}
                    far={1000}
                  />}
                />}
              />
              <mesh
                geometry={clothGeometry}
                material={clothMaterial}
                position={new THREE.Vector3(0, 0, 0)}
                castShadow
                customDepthMaterial={<meshDepthMaterial
                  depthPacking={THREE.RGBADepthPacking}
                  map={clothTexture}
                  alphaTest={0.5}
                />}
              />
              <mesh
                name="sphere"
                geometry={<sphereBufferGeometry
                  radius={ballSize}
                  widthSegments={32}
                  heightSegments={16}
                />}
                material={<meshLambertMaterial/>}
                castShadow
                receiveShadow

                ref={sphereRef}
              />
            </scene>
          </webGLRenderer>
        </React3>;
      }
    }

    ReactDOM.render(<ClothExample/>, container);

    /**/

    // // sphere
    //
    //
    // sphere = new THREE.Mesh(ballGeo, ballMaterial);
    // sphere.castShadow = true;
    // sphere.receiveShadow = true;
    // scene.add(sphere);
    //
    // // ground
    //
    // var groundTexture = loader.load('textures/terrain/grasslight-big.jpg');
    // groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
    // groundTexture.repeat.set(25, 25);
    // groundTexture.anisotropy = 16;
    //
    // var groundMaterial = new THREE.MeshLambertMaterial({map: groundTexture});
    //
    // var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000), groundMaterial);
    // mesh.position.y = -250;
    // mesh.rotation.x = -Math.PI / 2;
    // mesh.receiveShadow = true;
    // scene.add(mesh);
    //
    // // poles
    //
    // var poleGeo = new THREE.BoxBufferGeometry(5, 375, 5);
    // var poleMat = new THREE.MeshLambertMaterial();
    //
    // var mesh = new THREE.Mesh(poleGeo, poleMat);
    // mesh.position.x = -125;
    // mesh.position.y = -62;
    // mesh.receiveShadow = true;
    // mesh.castShadow = true;
    // scene.add(mesh);
    //
    // var mesh = new THREE.Mesh(poleGeo, poleMat);
    // mesh.position.x = 125;
    // mesh.position.y = -62;
    // mesh.receiveShadow = true;
    // mesh.castShadow = true;
    // scene.add(mesh);
    //
    // var mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(255, 5, 5), poleMat);
    // mesh.position.y = -250 + (750 / 2);
    // mesh.position.x = 0;
    // mesh.receiveShadow = true;
    // mesh.castShadow = true;
    // scene.add(mesh);
    //
    // var gg = new THREE.BoxBufferGeometry(10, 10, 10);
    // var mesh = new THREE.Mesh(gg, poleMat);
    // mesh.position.y = -250;
    // mesh.position.x = 125;
    // mesh.receiveShadow = true;
    // mesh.castShadow = true;
    // scene.add(mesh);
    //
    // var mesh = new THREE.Mesh(gg, poleMat);
    // mesh.position.y = -250;
    // mesh.position.x = -125;
    // mesh.receiveShadow = true;
    // mesh.castShadow = true;
    // scene.add(mesh);
    //
    // // renderer
    //
    // renderer = new THREE.WebGLRenderer({antialias: true});
    // renderer.setPixelRatio(window.devicePixelRatio);
    // renderer.setSize(window.innerWidth, window.innerHeight);


    //
    // container.appendChild(renderer.domElement);
    //
    // renderer.gammaInput = true;
    // renderer.gammaOutput = true;
    //
    // renderer.shadowMap.enabled = true;
    //
    // // controls
    // var controls = new THREE.OrbitControls(camera, renderer.domElement);
    // controls.maxPolarAngle = Math.PI * 0.5;
    // controls.minDistance = 1000;
    // controls.maxDistance = 5000;
    //
    // // performance monitor
    //
    stats = new Stats();
    container.appendChild(stats.dom);
    //
    // //
    //
    // window.addEventListener('resize', onWindowResize, false);
    //
    // sphere.visible = !true;

  }

  //

  function onWindowResize() {

    // camera.aspect = window.innerWidth / window.innerHeight;
    // camera.updateProjectionMatrix();
    //
    // renderer.setSize(window.innerWidth, window.innerHeight);

  }

  //

  function animate() {

    requestAnimationFrame(animate);

    var time = Date.now();

    var windStrength = Math.cos(time / 7000) * 20 + 40;

    windForce.set(Math.sin(time / 2000), Math.cos(time / 3000), Math.sin(time / 1000))
    windForce.normalize()
    windForce.multiplyScalar(windStrength);

    simulate(time);
    render();
    stats.update();

  }

  function render() {

    var p = cloth.particles;

    for (var i = 0, il = p.length; i < il; i++) {

      clothGeometry.vertices[i].copy(p[i].position);

    }

    clothGeometry.verticesNeedUpdate = true;

    clothGeometry.computeFaceNormals();
    clothGeometry.computeVertexNormals();

    sphere.position.copy(ballPosition);

    renderer.render(scene, camera);

    ReactDOM.render(<ClothExample/>, container);
  }

</script>
</body>
</html>
